// Code generated by @apexlang/codegen. DO NOT EDIT.

package outputtest

import (
	"context"

	"github.com/google/uuid"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"

	"github.com/apexlang/api-go/convert"
	"github.com/apexlang/api-go/errorz"
	"github.com/apexlang/api-go/transport/tgrpc"

	pb "github.com/apexlang/outputtest/proto"
)

const (
	_ = convert.Package
	_ = errorz.Package
)

func MyServiceGRPC(s MyService) tgrpc.RegisterFn {
	return func(server grpc.ServiceRegistrar) {
		pb.RegisterMyServiceServer(server, NewMyServiceGRPCWrapper(s))
	}
}

type MyServiceGRPCWrapper struct {
	pb.UnimplementedMyServiceServer
	service MyService
}

func NewMyServiceGRPCWrapper(service MyService) *MyServiceGRPCWrapper {
	return &MyServiceGRPCWrapper{
		service: service,
	}
}

func (s *MyServiceGRPCWrapper) EmptyVoid(ctx context.Context, _ *emptypb.Empty) (*emptypb.Empty, error) {
	err := s.service.EmptyVoid(ctx)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &emptypb.Empty{}, nil
}

func (s *MyServiceGRPCWrapper) UnaryType(ctx context.Context, request *pb.MyType) (*pb.MyType, error) {
	input, err := convertInputMyType(request)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	result, err := s.service.UnaryType(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return convertOutputMyType(result), nil
}

func (s *MyServiceGRPCWrapper) UnaryEnum(ctx context.Context, value *pb.MyEnumValue) (*pb.MyEnumValue, error) {
	input := MyEnum(value.Value)
	result, err := s.service.UnaryEnum(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &pb.MyEnumValue{Value: pb.MyEnum(result)}, nil
}

func (s *MyServiceGRPCWrapper) UnaryAlias(ctx context.Context, value *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	input, err := uuid.Parse(value.Value)
	if err != nil {
		return nil, tgrpc.Error(errorz.Newf(errorz.InvalidArgument, "Invalid argument for value"))
	}
	result, err := s.service.UnaryAlias(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.StringValue{Value: result.String()}, nil
}

func (s *MyServiceGRPCWrapper) UnaryString(ctx context.Context, value *wrapperspb.StringValue) (*wrapperspb.StringValue, error) {
	input := value.Value
	result, err := s.service.UnaryString(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.StringValue{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) UnaryI64(ctx context.Context, value *wrapperspb.Int64Value) (*wrapperspb.Int64Value, error) {
	input := value.Value
	result, err := s.service.UnaryI64(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int64Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) UnaryI32(ctx context.Context, value *wrapperspb.Int32Value) (*wrapperspb.Int32Value, error) {
	input := value.Value
	result, err := s.service.UnaryI32(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int32Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) UnaryI16(ctx context.Context, value *wrapperspb.Int32Value) (*wrapperspb.Int32Value, error) {
	input := int16(value.Value)
	result, err := s.service.UnaryI16(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int32Value{Value: int32(result)}, nil
}

func (s *MyServiceGRPCWrapper) UnaryI8(ctx context.Context, value *wrapperspb.Int32Value) (*wrapperspb.Int32Value, error) {
	input := int8(value.Value)
	result, err := s.service.UnaryI8(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int32Value{Value: int32(result)}, nil
}

func (s *MyServiceGRPCWrapper) UnaryU64(ctx context.Context, value *wrapperspb.UInt64Value) (*wrapperspb.UInt64Value, error) {
	input := value.Value
	result, err := s.service.UnaryU64(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt64Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) UnaryU32(ctx context.Context, value *wrapperspb.UInt32Value) (*wrapperspb.UInt32Value, error) {
	input := value.Value
	result, err := s.service.UnaryU32(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt32Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) UnaryU16(ctx context.Context, value *wrapperspb.UInt32Value) (*wrapperspb.UInt32Value, error) {
	input := uint16(value.Value)
	result, err := s.service.UnaryU16(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt32Value{Value: uint32(result)}, nil
}

func (s *MyServiceGRPCWrapper) UnaryU8(ctx context.Context, value *wrapperspb.UInt32Value) (*wrapperspb.UInt32Value, error) {
	input := uint8(value.Value)
	result, err := s.service.UnaryU8(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt32Value{Value: uint32(result)}, nil
}

func (s *MyServiceGRPCWrapper) UnaryF64(ctx context.Context, value *wrapperspb.DoubleValue) (*wrapperspb.DoubleValue, error) {
	input := value.Value
	result, err := s.service.UnaryF64(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.DoubleValue{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) UnaryF32(ctx context.Context, value *wrapperspb.FloatValue) (*wrapperspb.FloatValue, error) {
	input := value.Value
	result, err := s.service.UnaryF32(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.FloatValue{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) UnaryBytes(ctx context.Context, value *wrapperspb.BytesValue) (*wrapperspb.BytesValue, error) {
	input := value.Value
	result, err := s.service.UnaryBytes(ctx, input)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.BytesValue{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncType(ctx context.Context, args *pb.FuncTypeArgs) (*pb.MyType, error) {
	type FuncTypeArgs struct {
		Value    MyType  `json:"value" yaml:"value" msgpack:"value"`
		Optional *MyType `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncTypeArgs{
		Value:    *errorz.Track(&et, convertInputMyType, args.Value),
		Optional: errorz.Track(&et, convertInputMyType, args.Optional),
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncType(ctx, &input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return convertOutputMyType(result), nil
}

func (s *MyServiceGRPCWrapper) FuncEnum(ctx context.Context, args *pb.FuncEnumArgs) (*pb.MyEnumValue, error) {
	type FuncEnumArgs struct {
		Value    MyEnum  `json:"value" yaml:"value" msgpack:"value"`
		Optional *MyEnum `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncEnumArgs{
		Value:    MyEnum(args.Value),
		Optional: (*MyEnum)(args.Optional),
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncEnum(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &pb.MyEnumValue{Value: pb.MyEnum(result)}, nil
}

func (s *MyServiceGRPCWrapper) FuncAlias(ctx context.Context, args *pb.FuncAliasArgs) (*wrapperspb.StringValue, error) {
	type FuncAliasArgs struct {
		Value    uuid.UUID  `json:"value" yaml:"value" msgpack:"value"`
		Optional *uuid.UUID `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncAliasArgs{
		Value:    errorz.Track(&et, uuid.Parse, args.Value),
		Optional: convert.NillableEt(&et, args.Optional, uuid.Parse),
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncAlias(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.StringValue{Value: result.String()}, nil
}

func (s *MyServiceGRPCWrapper) FuncString(ctx context.Context, args *pb.FuncStringArgs) (*wrapperspb.StringValue, error) {
	type FuncStringArgs struct {
		Value    string  `json:"value" yaml:"value" msgpack:"value"`
		Optional *string `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncStringArgs{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncString(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.StringValue{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncI64(ctx context.Context, args *pb.FuncI64Args) (*wrapperspb.Int64Value, error) {
	type FuncI64Args struct {
		Value    int64  `json:"value" yaml:"value" msgpack:"value"`
		Optional *int64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncI64Args{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncI64(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int64Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncI32(ctx context.Context, args *pb.FuncI32Args) (*wrapperspb.Int32Value, error) {
	type FuncI32Args struct {
		Value    int32  `json:"value" yaml:"value" msgpack:"value"`
		Optional *int32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncI32Args{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncI32(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int32Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncI16(ctx context.Context, args *pb.FuncI16Args) (*wrapperspb.Int32Value, error) {
	type FuncI16Args struct {
		Value    int16  `json:"value" yaml:"value" msgpack:"value"`
		Optional *int16 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncI16Args{
		Value:    int16(args.Value),
		Optional: tgrpc.ConvertInputI16Ptr(args.Optional),
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncI16(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int32Value{Value: int32(result)}, nil
}

func (s *MyServiceGRPCWrapper) FuncI8(ctx context.Context, args *pb.FuncI8Args) (*wrapperspb.Int32Value, error) {
	type FuncI8Args struct {
		Value    int8  `json:"value" yaml:"value" msgpack:"value"`
		Optional *int8 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncI8Args{
		Value:    int8(args.Value),
		Optional: tgrpc.ConvertInputI8Ptr(args.Optional),
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncI8(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.Int32Value{Value: int32(result)}, nil
}

func (s *MyServiceGRPCWrapper) FuncU64(ctx context.Context, args *pb.FuncU64Args) (*wrapperspb.UInt64Value, error) {
	type FuncU64Args struct {
		Value    uint64  `json:"value" yaml:"value" msgpack:"value"`
		Optional *uint64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncU64Args{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncU64(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt64Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncU32(ctx context.Context, args *pb.FuncU32Args) (*wrapperspb.UInt32Value, error) {
	type FuncU32Args struct {
		Value    uint32  `json:"value" yaml:"value" msgpack:"value"`
		Optional *uint32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncU32Args{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncU32(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt32Value{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncU16(ctx context.Context, args *pb.FuncU16Args) (*wrapperspb.UInt32Value, error) {
	type FuncU16Args struct {
		Value    uint16  `json:"value" yaml:"value" msgpack:"value"`
		Optional *uint16 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncU16Args{
		Value:    uint16(args.Value),
		Optional: tgrpc.ConvertInputU16Ptr(args.Optional),
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncU16(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt32Value{Value: uint32(result)}, nil
}

func (s *MyServiceGRPCWrapper) FuncU8(ctx context.Context, args *pb.FuncU8Args) (*wrapperspb.UInt32Value, error) {
	type FuncU8Args struct {
		Value    uint8  `json:"value" yaml:"value" msgpack:"value"`
		Optional *uint8 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncU8Args{
		Value:    uint8(args.Value),
		Optional: tgrpc.ConvertInputU8Ptr(args.Optional),
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncU8(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.UInt32Value{Value: uint32(result)}, nil
}

func (s *MyServiceGRPCWrapper) FuncF64(ctx context.Context, args *pb.FuncF64Args) (*wrapperspb.DoubleValue, error) {
	type FuncF64Args struct {
		Value    float64  `json:"value" yaml:"value" msgpack:"value"`
		Optional *float64 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncF64Args{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncF64(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.DoubleValue{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncF32(ctx context.Context, args *pb.FuncF32Args) (*wrapperspb.FloatValue, error) {
	type FuncF32Args struct {
		Value    float32  `json:"value" yaml:"value" msgpack:"value"`
		Optional *float32 `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncF32Args{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncF32(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.FloatValue{Value: result}, nil
}

func (s *MyServiceGRPCWrapper) FuncBytes(ctx context.Context, args *pb.FuncBytesArgs) (*wrapperspb.BytesValue, error) {
	type FuncBytesArgs struct {
		Value    []byte `json:"value" yaml:"value" msgpack:"value"`
		Optional []byte `json:"optional,omitempty" yaml:"optional,omitempty" msgpack:"optional,omitempty"`
	}

	var et errorz.Tracker
	input := FuncBytesArgs{
		Value:    args.Value,
		Optional: args.Optional,
	}
	if errz := et.Errors(); errz != nil {
		return nil, tgrpc.Error(errz)
	}
	result, err := s.service.FuncBytes(ctx, input.Value, input.Optional)
	if err != nil {
		return nil, tgrpc.Error(err)
	}
	return &wrapperspb.BytesValue{Value: result}, nil
}

func convertInputMyType(from *pb.MyType) (*MyType, error) {
	if from == nil {
		return nil, nil
	}
	var et errorz.Tracker

	result := MyType{
		SameValue:      errorz.Track(&et, convertInputMyType, from.SameValue),
		TypeValue:      *errorz.Track(&et, convertInputMyOtherType, from.TypeValue),
		StringValue:    from.StringValue,
		StringOption:   from.StringOption,
		I64Value:       from.I64Value,
		I64Option:      from.I64Option,
		I32Value:       from.I32Value,
		I32Option:      from.I32Option,
		I16Value:       int16(from.I16Value),
		I16Option:      tgrpc.ConvertInputI16Ptr(from.I16Option),
		I8Value:        int8(from.I8Value),
		I8Option:       tgrpc.ConvertInputI8Ptr(from.I8Option),
		U64Value:       from.U64Value,
		U64Option:      from.U64Option,
		U32Value:       from.U32Value,
		U32Option:      from.U32Option,
		U16Value:       uint16(from.U16Value),
		U16Option:      tgrpc.ConvertInputU16Ptr(from.U16Option),
		U8Value:        uint8(from.U8Value),
		U8Option:       tgrpc.ConvertInputU8Ptr(from.U8Option),
		F64Value:       from.F64Value,
		F64Option:      from.F64Option,
		F32Value:       from.F32Value,
		F32Option:      from.F32Option,
		DatetimeValue:  from.DatetimeValue.AsTime(),
		DatetimeOption: tgrpc.ConvertInputTimestamp(from.DatetimeOption),
		BytesValue:     from.BytesValue,
		BytesOption:    from.BytesOption,
		MapValue:       from.MapValue,
		MapOfTypes:     convert.MapRefEt(&et, from.MapOfTypes, convertInputMyType),
		ArrayValue:     from.ArrayValue,
		ArrayOfTypes:   convert.SliceRefEt(&et, from.ArrayOfTypes, convertInputMyType),
		UnionValue:     *errorz.Track(&et, convertInputMyUnion, from.UnionValue),
		UnionOption:    errorz.Track(&et, convertInputMyUnion, from.UnionOption),
		EnumValue:      MyEnum(from.EnumValue),
		EnumOption:     (*MyEnum)(from.EnumOption),
		AliasValue:     errorz.Track(&et, uuid.Parse, from.AliasValue),
		AliasOption:    convert.NillableEt(&et, from.AliasOption, uuid.Parse),
	}
	if errz := et.Errors(); errz != nil {
		return nil, errz
	}

	return &result, nil
}

func convertInputMyOtherType(from *pb.MyOtherType) (*MyOtherType, error) {
	if from == nil {
		return nil, nil
	}
	var et errorz.Tracker

	result := MyOtherType{
		Foo: from.Foo,
		Bar: from.Bar,
	}
	if errz := et.Errors(); errz != nil {
		return nil, errz
	}

	return &result, nil
}

func convertInputMyUnion(from *pb.MyUnion) (*MyUnion, error) {
	if from == nil {
		return nil, nil
	}
	switch v := from.Value.(type) {
	case *pb.MyUnion_MyTypeValue:
		vMyTypeValue, err := convertInputMyType(v.MyTypeValue)
		return &MyUnion{
			MyType: vMyTypeValue,
		}, err
	case *pb.MyUnion_MyEnumValue:
		return &MyUnion{
			MyEnum: convert.Ptr(MyEnum(v.MyEnumValue)),
		}, nil
	case *pb.MyUnion_StringValue:
		return &MyUnion{
			String: &v.StringValue,
		}, nil
	}
	return nil, nil
}

func convertOutputMyType(from *MyType) *pb.MyType {
	if from == nil {
		return nil
	}
	return &pb.MyType{
		SameValue:      convertOutputMyType(from.SameValue),
		TypeValue:      convertOutputMyOtherType(&from.TypeValue),
		StringValue:    from.StringValue,
		StringOption:   from.StringOption,
		I64Value:       from.I64Value,
		I64Option:      from.I64Option,
		I32Value:       from.I32Value,
		I32Option:      from.I32Option,
		I16Value:       int32(from.I16Value),
		I16Option:      tgrpc.ConvertOutputI16Ptr(from.I16Option),
		I8Value:        int32(from.I8Value),
		I8Option:       tgrpc.ConvertOutputI8Ptr(from.I8Option),
		U64Value:       from.U64Value,
		U64Option:      from.U64Option,
		U32Value:       from.U32Value,
		U32Option:      from.U32Option,
		U16Value:       uint32(from.U16Value),
		U16Option:      tgrpc.ConvertOutputU16Ptr(from.U16Option),
		U8Value:        uint32(from.U8Value),
		U8Option:       tgrpc.ConvertOutputU8Ptr(from.U8Option),
		F64Value:       from.F64Value,
		F64Option:      from.F64Option,
		F32Value:       from.F32Value,
		F32Option:      from.F32Option,
		DatetimeValue:  timestamppb.New(from.DatetimeValue),
		DatetimeOption: tgrpc.ConvertOutputTimestamp(from.DatetimeOption),
		BytesValue:     from.BytesValue,
		BytesOption:    from.BytesOption,
		MapValue:       from.MapValue,
		MapOfTypes:     convert.MapPtr(from.MapOfTypes, convertOutputMyType),
		ArrayValue:     from.ArrayValue,
		ArrayOfTypes:   convert.SlicePtr(from.ArrayOfTypes, convertOutputMyType),
		UnionValue:     convertOutputMyUnion(&from.UnionValue),
		UnionOption:    convertOutputMyUnion(from.UnionOption),
		EnumValue:      pb.MyEnum(from.EnumValue),
		EnumOption:     (*pb.MyEnum)(from.EnumOption),
		AliasValue:     from.AliasValue.String(),
		AliasOption: convert.Nillable(from.AliasOption, func(value uuid.UUID) string {
			return value.String()
		}),
	}
}

func convertOutputMyOtherType(from *MyOtherType) *pb.MyOtherType {
	if from == nil {
		return nil
	}
	return &pb.MyOtherType{
		Foo: from.Foo,
		Bar: from.Bar,
	}
}

func convertOutputMyUnion(from *MyUnion) *pb.MyUnion {
	if from == nil {
		return nil
	}
	switch {
	case from.MyType != nil:
		return &pb.MyUnion{
			Value: &pb.MyUnion_MyTypeValue{
				MyTypeValue: convertOutputMyType(from.MyType),
			},
		}
	case from.MyEnum != nil:
		return &pb.MyUnion{
			Value: &pb.MyUnion_MyEnumValue{
				MyEnumValue: pb.MyEnum(*from.MyEnum),
			},
		}
	case from.String != nil:
		return &pb.MyUnion{
			Value: &pb.MyUnion_StringValue{
				StringValue: *from.String,
			},
		}
	}
	return nil
}

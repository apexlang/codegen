// Code generated by @apexlang/codegen. DO NOT EDIT.

package outputtest

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
)

type ns struct{}

func (n *ns) Namespace() string {
	return "apex.testing"
}

type MyService interface {
	EmptyVoid(ctx context.Context) error
	UnaryType(ctx context.Context, value *MyType) (*MyType, error)
	UnaryEnum(ctx context.Context, value MyEnum) (MyEnum, error)
	UnaryAlias(ctx context.Context, value uuid.UUID) (uuid.UUID, error)
	UnaryString(ctx context.Context, value string) (string, error)
	UnaryI64(ctx context.Context, value int64) (int64, error)
	UnaryI32(ctx context.Context, value int32) (int32, error)
	UnaryI16(ctx context.Context, value int16) (int16, error)
	UnaryI8(ctx context.Context, value int8) (int8, error)
	UnaryU64(ctx context.Context, value uint64) (uint64, error)
	UnaryU32(ctx context.Context, value uint32) (uint32, error)
	UnaryU16(ctx context.Context, value uint16) (uint16, error)
	UnaryU8(ctx context.Context, value uint8) (uint8, error)
	UnaryF64(ctx context.Context, value float64) (float64, error)
	UnaryF32(ctx context.Context, value float32) (float32, error)
	UnaryBytes(ctx context.Context, value []byte) ([]byte, error)
	FuncType(ctx context.Context, value *MyType, optional *MyType) (*MyType, error)
	FuncEnum(ctx context.Context, value MyEnum, optional *MyEnum) (MyEnum, error)
	FuncAlias(ctx context.Context, value uuid.UUID, optional *uuid.UUID) (uuid.UUID, error)
	FuncString(ctx context.Context, value string, optional *string) (string, error)
	FuncI64(ctx context.Context, value int64, optional *int64) (int64, error)
	FuncI32(ctx context.Context, value int32, optional *int32) (int32, error)
	FuncI16(ctx context.Context, value int16, optional *int16) (int16, error)
	FuncI8(ctx context.Context, value int8, optional *int8) (int8, error)
	FuncU64(ctx context.Context, value uint64, optional *uint64) (uint64, error)
	FuncU32(ctx context.Context, value uint32, optional *uint32) (uint32, error)
	FuncU16(ctx context.Context, value uint16, optional *uint16) (uint16, error)
	FuncU8(ctx context.Context, value uint8, optional *uint8) (uint8, error)
	FuncF64(ctx context.Context, value float64, optional *float64) (float64, error)
	FuncF32(ctx context.Context, value float32, optional *float32) (float32, error)
	FuncBytes(ctx context.Context, value []byte, optional []byte) ([]byte, error)
}

type Repository interface {
	GetData(ctx context.Context) (*MyType, error)
}

// MyType is a class
type MyType struct {
	ns
	// same type value
	SameValue *MyType `json:"sameValue,omitempty" yaml:"sameValue,omitempty" msgpack:"sameValue,omitempty"`
	// type value
	TypeValue MyOtherType `json:"typeValue" yaml:"typeValue" msgpack:"typeValue"`
	// string value
	StringValue string `json:"stringValue" yaml:"stringValue" msgpack:"stringValue"`
	// string option
	StringOption *string `json:"stringOption,omitempty" yaml:"stringOption,omitempty" msgpack:"stringOption,omitempty"`
	// i64 value
	I64Value int64 `json:"i64Value" yaml:"i64Value" msgpack:"i64Value"`
	// i64 option
	I64Option *int64 `json:"i64Option,omitempty" yaml:"i64Option,omitempty" msgpack:"i64Option,omitempty"`
	// i32 value
	I32Value int32 `json:"i32Value" yaml:"i32Value" msgpack:"i32Value"`
	// i32 option
	I32Option *int32 `json:"i32Option,omitempty" yaml:"i32Option,omitempty" msgpack:"i32Option,omitempty"`
	// i16 value
	I16Value int16 `json:"i16Value" yaml:"i16Value" msgpack:"i16Value"`
	// i16 option
	I16Option *int16 `json:"i16Option,omitempty" yaml:"i16Option,omitempty" msgpack:"i16Option,omitempty"`
	// i8 value
	I8Value int8 `json:"i8Value" yaml:"i8Value" msgpack:"i8Value"`
	// i8 option
	I8Option *int8 `json:"i8Option,omitempty" yaml:"i8Option,omitempty" msgpack:"i8Option,omitempty"`
	// u64 value
	U64Value uint64 `json:"u64Value" yaml:"u64Value" msgpack:"u64Value"`
	// u64 option
	U64Option *uint64 `json:"u64Option,omitempty" yaml:"u64Option,omitempty" msgpack:"u64Option,omitempty"`
	// u32 value
	U32Value uint32 `json:"u32Value" yaml:"u32Value" msgpack:"u32Value"`
	// u32 option
	U32Option *uint32 `json:"u32Option,omitempty" yaml:"u32Option,omitempty" msgpack:"u32Option,omitempty"`
	// u16 value
	U16Value uint16 `json:"u16Value" yaml:"u16Value" msgpack:"u16Value"`
	// u16 option
	U16Option *uint16 `json:"u16Option,omitempty" yaml:"u16Option,omitempty" msgpack:"u16Option,omitempty"`
	// u8 value
	U8Value uint8 `json:"u8Value" yaml:"u8Value" msgpack:"u8Value"`
	// u8 option
	U8Option *uint8 `json:"u8Option,omitempty" yaml:"u8Option,omitempty" msgpack:"u8Option,omitempty"`
	// f64 value
	F64Value float64 `json:"f64Value" yaml:"f64Value" msgpack:"f64Value"`
	// f64 option
	F64Option *float64 `json:"f64Option,omitempty" yaml:"f64Option,omitempty" msgpack:"f64Option,omitempty"`
	// f32 value
	F32Value float32 `json:"f32Value" yaml:"f32Value" msgpack:"f32Value"`
	// f32 option
	F32Option *float32 `json:"f32Option,omitempty" yaml:"f32Option,omitempty" msgpack:"f32Option,omitempty"`
	// datetime value
	DatetimeValue time.Time `json:"datetimeValue" yaml:"datetimeValue" msgpack:"datetimeValue"`
	// datetime option
	DatetimeOption *time.Time `json:"datetimeOption,omitempty" yaml:"datetimeOption,omitempty" msgpack:"datetimeOption,omitempty"`
	// bytes value
	BytesValue []byte `json:"bytesValue" yaml:"bytesValue" msgpack:"bytesValue"`
	// bytes option
	BytesOption []byte `json:"bytesOption,omitempty" yaml:"bytesOption,omitempty" msgpack:"bytesOption,omitempty"`
	// map value
	MapValue map[string]int64 `json:"mapValue" yaml:"mapValue" msgpack:"mapValue"`
	// map of types
	MapOfTypes map[string]MyType `json:"mapOfTypes" yaml:"mapOfTypes" msgpack:"mapOfTypes"`
	// array value
	ArrayValue []string `json:"arrayValue" yaml:"arrayValue" msgpack:"arrayValue"`
	// array of types
	ArrayOfTypes []MyType `json:"arrayOfTypes" yaml:"arrayOfTypes" msgpack:"arrayOfTypes"`
	// union value
	UnionValue MyUnion `json:"unionValue" yaml:"unionValue" msgpack:"unionValue"`
	// union option
	UnionOption *MyUnion `json:"unionOption,omitempty" yaml:"unionOption,omitempty" msgpack:"unionOption,omitempty"`
	// enum value
	EnumValue MyEnum `json:"enumValue" yaml:"enumValue" msgpack:"enumValue"`
	// enum option
	EnumOption *MyEnum `json:"enumOption,omitempty" yaml:"enumOption,omitempty" msgpack:"enumOption,omitempty"`
	// enum value
	AliasValue uuid.UUID `json:"aliasValue" yaml:"aliasValue" msgpack:"aliasValue"`
	// enum option
	AliasOption *uuid.UUID `json:"aliasOption,omitempty" yaml:"aliasOption,omitempty" msgpack:"aliasOption,omitempty"`
}

func (m *MyType) Type() string {
	return "MyType"
}

type MyOtherType struct {
	ns
	Foo string `json:"foo" yaml:"foo" msgpack:"foo"`
	Bar string `json:"bar" yaml:"bar" msgpack:"bar"`
}

func (m *MyOtherType) Type() string {
	return "MyOtherType"
}

type MyUnion struct {
	MyType *MyType `json:"MyType,omitempty" yaml:"MyType,omitempty" msgpack:"MyType,omitempty"`
	MyEnum *MyEnum `json:"MyEnum,omitempty" yaml:"MyEnum,omitempty" msgpack:"MyEnum,omitempty"`
	String *string `json:"string,omitempty" yaml:"string,omitempty" msgpack:"string,omitempty"`
}

// MyEnum is an emuneration
type MyEnum int32

const (
	// ONE value
	MyEnumOne MyEnum = 0
	// TWO value
	MyEnumTwo MyEnum = 1
	// THREE value
	MyEnumThree MyEnum = 2
)

var toStringMyEnum = map[MyEnum]string{
	MyEnumOne:   "one",
	MyEnumTwo:   "TWO",
	MyEnumThree: "three",
}

var toIDMyEnum = map[string]MyEnum{
	"one":   MyEnumOne,
	"TWO":   MyEnumTwo,
	"three": MyEnumThree,
}

func (e MyEnum) Type() string {
	return "MyEnum"
}

func (e MyEnum) String() string {
	str, ok := toStringMyEnum[e]
	if !ok {
		return "unknown"
	}
	return str
}

func (e *MyEnum) FromString(str string) (ok bool) {
	*e, ok = toIDMyEnum[str]
	return ok
}

// MarshalJSON marshals the enum as a quoted json string
func (e MyEnum) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.String())
}

// UnmarshalJSON unmashals a quoted json string to the enum value
func (e *MyEnum) UnmarshalJSON(b []byte) error {
	var str string
	err := json.Unmarshal(b, &str)
	if err != nil {
		return err
	}
	if !e.FromString(str) {
		return fmt.Errorf("unknown value %q for MyEnum", str)
	}
	return nil
}

// Code generated by @apexlang/codegen. DO NOT EDIT.

package outputtest

import (
	"github.com/google/uuid"
	"github.com/wapc/tinygo-msgpack"
	"github.com/wapc/tinygo-msgpack/convert"
)

var _ = convert.Package

func (o *MyType) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "sameValue":
			o.SameValue, err = msgpack.DecodeNillable[MyType](decoder)
		case "typeValue":
			err = o.TypeValue.Decode(decoder)
		case "stringValue":
			o.StringValue, err = decoder.ReadString()
		case "stringOption":
			o.StringOption, err = decoder.ReadNillableString()
		case "i64Value":
			o.I64Value, err = decoder.ReadInt64()
		case "i64Option":
			o.I64Option, err = decoder.ReadNillableInt64()
		case "i32Value":
			o.I32Value, err = decoder.ReadInt32()
		case "i32Option":
			o.I32Option, err = decoder.ReadNillableInt32()
		case "i16Value":
			o.I16Value, err = decoder.ReadInt16()
		case "i16Option":
			o.I16Option, err = decoder.ReadNillableInt16()
		case "i8Value":
			o.I8Value, err = decoder.ReadInt8()
		case "i8Option":
			o.I8Option, err = decoder.ReadNillableInt8()
		case "u64Value":
			o.U64Value, err = decoder.ReadUint64()
		case "u64Option":
			o.U64Option, err = decoder.ReadNillableUint64()
		case "u32Value":
			o.U32Value, err = decoder.ReadUint32()
		case "u32Option":
			o.U32Option, err = decoder.ReadNillableUint32()
		case "u16Value":
			o.U16Value, err = decoder.ReadUint16()
		case "u16Option":
			o.U16Option, err = decoder.ReadNillableUint16()
		case "u8Value":
			o.U8Value, err = decoder.ReadUint8()
		case "u8Option":
			o.U8Option, err = decoder.ReadNillableUint8()
		case "f64Value":
			o.F64Value, err = decoder.ReadFloat64()
		case "f64Option":
			o.F64Option, err = decoder.ReadNillableFloat64()
		case "f32Value":
			o.F32Value, err = decoder.ReadFloat32()
		case "f32Option":
			o.F32Option, err = decoder.ReadNillableFloat32()
		case "datetimeValue":
			o.DatetimeValue, err = convert.StringToTime(decoder.ReadString())
		case "datetimeOption":
			o.DatetimeOption, err = convert.StringToTimePtr(decoder.ReadNillableString())
		case "bytesValue":
			o.BytesValue, err = decoder.ReadByteArray()
		case "bytesOption":
			o.BytesOption, err = decoder.ReadNillableByteArray()
		case "mapValue":
			mapSize, err := decoder.ReadMapSize()
			if err != nil {
				return err
			}
			o.MapValue = make(map[string]int64, mapSize)
			for mapSize > 0 {
				mapSize--
				key, err := decoder.ReadString()
				if err != nil {
					return err
				}
				value, err := decoder.ReadInt64()
				if err != nil {
					return err
				}
				o.MapValue[key] = value
			}
		case "mapOfTypes":
			mapSize, err := decoder.ReadMapSize()
			if err != nil {
				return err
			}
			o.MapOfTypes = make(map[string]MyType, mapSize)
			for mapSize > 0 {
				mapSize--
				key, err := decoder.ReadString()
				if err != nil {
					return err
				}
				value, err := msgpack.Decode[MyType](decoder)
				if err != nil {
					return err
				}
				o.MapOfTypes[key] = value
			}
		case "arrayValue":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.ArrayValue = make([]string, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem string
				nonNilItem, err = decoder.ReadString()
				if err != nil {
					return err
				}
				o.ArrayValue = append(o.ArrayValue, nonNilItem)
			}
		case "arrayOfTypes":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.ArrayOfTypes = make([]MyType, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem MyType
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.ArrayOfTypes = append(o.ArrayOfTypes, nonNilItem)
			}
		case "unionValue":
			o.UnionValue, err = msgpack.Decode[MyUnion](decoder)
		case "unionOption":
			o.UnionOption, err = msgpack.DecodeNillable[MyUnion](decoder)
		case "enumValue":
			o.EnumValue, err = convert.Numeric[MyEnum](decoder.ReadInt32())
		case "enumOption":
			o.EnumOption, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		case "aliasValue":
			o.AliasValue, err = convert.Parse(uuid.Parse)(decoder.ReadString())
		case "aliasOption":
			o.AliasOption, err = convert.NillableParse(uuid.Parse)(decoder.ReadNillableString())
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyType) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(38)
	encoder.WriteString("sameValue")
	o.SameValue.Encode(encoder)
	encoder.WriteString("typeValue")
	o.TypeValue.Encode(encoder)
	encoder.WriteString("stringValue")
	encoder.WriteString(o.StringValue)
	encoder.WriteString("stringOption")
	encoder.WriteNillableString(o.StringOption)
	encoder.WriteString("i64Value")
	encoder.WriteInt64(o.I64Value)
	encoder.WriteString("i64Option")
	encoder.WriteNillableInt64(o.I64Option)
	encoder.WriteString("i32Value")
	encoder.WriteInt32(o.I32Value)
	encoder.WriteString("i32Option")
	encoder.WriteNillableInt32(o.I32Option)
	encoder.WriteString("i16Value")
	encoder.WriteInt16(o.I16Value)
	encoder.WriteString("i16Option")
	encoder.WriteNillableInt16(o.I16Option)
	encoder.WriteString("i8Value")
	encoder.WriteInt8(o.I8Value)
	encoder.WriteString("i8Option")
	encoder.WriteNillableInt8(o.I8Option)
	encoder.WriteString("u64Value")
	encoder.WriteUint64(o.U64Value)
	encoder.WriteString("u64Option")
	encoder.WriteNillableUint64(o.U64Option)
	encoder.WriteString("u32Value")
	encoder.WriteUint32(o.U32Value)
	encoder.WriteString("u32Option")
	encoder.WriteNillableUint32(o.U32Option)
	encoder.WriteString("u16Value")
	encoder.WriteUint16(o.U16Value)
	encoder.WriteString("u16Option")
	encoder.WriteNillableUint16(o.U16Option)
	encoder.WriteString("u8Value")
	encoder.WriteUint8(o.U8Value)
	encoder.WriteString("u8Option")
	encoder.WriteNillableUint8(o.U8Option)
	encoder.WriteString("f64Value")
	encoder.WriteFloat64(o.F64Value)
	encoder.WriteString("f64Option")
	encoder.WriteNillableFloat64(o.F64Option)
	encoder.WriteString("f32Value")
	encoder.WriteFloat32(o.F32Value)
	encoder.WriteString("f32Option")
	encoder.WriteNillableFloat32(o.F32Option)
	encoder.WriteString("datetimeValue")
	encoder.WriteString(convert.TimeToString(o.DatetimeValue))
	encoder.WriteString("datetimeOption")
	encoder.WriteNillableString(convert.TimeToStringPtr(o.DatetimeOption))
	encoder.WriteString("bytesValue")
	encoder.WriteByteArray(o.BytesValue)
	encoder.WriteString("bytesOption")
	encoder.WriteNillableByteArray(o.BytesOption)
	encoder.WriteString("mapValue")
	encoder.WriteMapSize(uint32(len(o.MapValue)))
	if o.MapValue != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.MapValue {
			encoder.WriteString(k)
			encoder.WriteInt64(v)
		}
	}
	encoder.WriteString("mapOfTypes")
	encoder.WriteMapSize(uint32(len(o.MapOfTypes)))
	if o.MapOfTypes != nil { // TinyGo bug: ranging over nil maps panics.
		for k, v := range o.MapOfTypes {
			encoder.WriteString(k)
			v.Encode(encoder)
		}
	}
	encoder.WriteString("arrayValue")
	encoder.WriteArraySize(uint32(len(o.ArrayValue)))
	for _, v := range o.ArrayValue {
		encoder.WriteString(v)
	}
	encoder.WriteString("arrayOfTypes")
	encoder.WriteArraySize(uint32(len(o.ArrayOfTypes)))
	for _, v := range o.ArrayOfTypes {
		v.Encode(encoder)
	}
	encoder.WriteString("unionValue")
	o.UnionValue.Encode(encoder)
	encoder.WriteString("unionOption")
	if o.UnionOption == nil {
		encoder.WriteNil()
	} else {
		o.UnionOption.Encode(encoder)
	}
	encoder.WriteString("enumValue")
	encoder.WriteInt32(int32(o.EnumValue))
	encoder.WriteString("enumOption")
	encoder.WriteNillableInt32((*int32)(o.EnumOption))
	encoder.WriteString("aliasValue")
	encoder.WriteString(o.AliasValue.String())
	encoder.WriteString("aliasOption")
	if o.AliasOption == nil {
		encoder.WriteNil()
	} else {
		encoder.WriteString(o.AliasOption.String())
	}

	return nil
}

func (o *MyOtherType) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "foo":
			o.Foo, err = decoder.ReadString()
		case "bar":
			o.Bar, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyOtherType) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("foo")
	encoder.WriteString(o.Foo)
	encoder.WriteString("bar")
	encoder.WriteString(o.Bar)

	return nil
}

func (o *MyUnion) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "MyType":
			o.MyType, err = msgpack.DecodeNillable[MyType](decoder)
		case "MyEnum":
			o.MyEnum, err = convert.NillableNumeric[MyEnum](decoder.ReadNillableInt32())
		case "string":
			o.String, err = decoder.ReadNillableString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *MyUnion) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	if o.MyType != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("MyType")
		o.MyType.Encode(encoder)
		return nil
	}
	if o.MyEnum != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("MyEnum")
		encoder.WriteNillableInt32((*int32)(o.MyEnum))
		return nil
	}
	if o.String != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("string")
		encoder.WriteNillableString(o.String)
		return nil
	}

	encoder.WriteNil()
	return nil
}
